#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2009,2011 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use Getopt::Long;

my $numeric;
my $reverse;
my $perlscript;

Getopt::Long::Configure("bundling");
GetOptions("n"   => \$numeric,
	   "r"   => \$reverse,
	   "e=s" => \$perlscript,
	  ) or die <<EOF;
usage: $0 [-n] [-r] -e ...

-n: compare numerically
-r: reverse sorting
-e: perl oneliner, should return the value to be compared as last value
EOF

my @data;
my $cb = defined $perlscript ? do {
    my $sub = eval "sub { $perlscript }";
    die $@ if $@;
    $sub;
} : sub { $_ };

if (@ARGV) {
    for my $file (@ARGV) {
	add_psort(do { open my $fh, $file or die "Can't open $file: $!"; $fh });
    }
} else {
    add_psort(\*STDIN);
}

if ($numeric) {
    no warnings 'numeric', 'uninitialized';
    if ($reverse) {
	@data = sort { $b->[1] <=> $a->[1] } @data;
    } else {
	@data = sort { $a->[1] <=> $b->[1] } @data;
    }
} else {
    no warnings 'uninitialized';
    if ($reverse) {
	@data = sort { $b->[1] cmp $a->[1] } @data;
    } else {
	@data = sort { $a->[1] cmp $b->[1] } @data;
    }
}

for (@data) {
    print $_->[0];
}

sub add_psort {
    my($fh) = @_;
    while(<$fh>) {
	my $line = $_;
	my $res = $cb->($_); # force scalar context
	push @data, [$line, $res];
    }
}

__END__
